Рассмотрим операцию `Mem-Copy(x, y)`, которая атомарно копирует значение из ячейки `x` в ячейку `y` и ничего не возвращает (т.е. скопированное значение можно узнать только с помощью последующего чтения).

Найдите число консенсуса для этой операции.

**Подсказка**: Как правило, поток, который "пришел" первым (т.е. первым выполнил атомарную операцию записи в память), выигрывает консенсус, а остальные потоки выбирают предложенное им значение. В данном случае решение будет хитрее.

---

Ответ: число консенсуса $`+\infty`$.

Докажем, что на любом количестве потоков достигается консенсус. Для этого заведем 3 массива: `copy_from`, `copy_in`, `values`. Первый изначально заполнен $`1`$-ми, второй – $`0`$-ми, третий будет заполняться значениями, которые предлагают потоки. 

Сначала каждый поток будет записывать значение которое он предлагает в `values` в ячейку, соответсвующую номеру потока. Затем совершать `Mem-Copy(copy_from[i], copy_in[i])`. А далее он будет производить `Mem-Copy(0, copy_from[j])` по очереди для всех $`j > i`$.  
Чтобы узнать какой из потоков победил, каждый поток будет проходиться по массиву `copy_in`с конца наперёд, в поисках первой единиыы. Индекс ячейки, в которой она нашлась – номер *потока-победителя*. 

Докажем что такая конструкция – `consensus`.
Победитель определяется однозначно для потока, так как мы берем крайнее положение единицы в `copy_in`. Победитель один и тот же для всех потоков, иначе была бы ситуация когда один поток выявил победителя $`i`$, а другой победителя $`j`$, причем $`i < j`$. В таком случае, первый поток, когда шёл в обратном направлении в поисках победителя, не увидел $`1`$ в `copy_in[j]`. Значит $`1`$ появилась позже этого обхода, но такого не могло произойти, так как в таком случае `copy_from[j]` точно обнулилось, и в `copy_in[j]` не могла копироваться единица. Победитель всегда достигается, так как первая запись в `copy_in[k]` никак не могла измениться. Таким образом выполнены требования *Agreement*, *Validity*. В силу того, что в конструкции нет условий и совершается проход по массиву конечной длины, то любой вызов завершается вне зависимости от остальных. Значит выполняется требование *Wait-Free Termination*.
