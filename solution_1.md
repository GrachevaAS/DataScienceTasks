### `[robust]` Робастность wait-free иерархии

Мы определили число консенсуса для операции $`O`$ как максимальное число потоков, которые за конечное число шагов могут выбрать общее значение, используя только атомарные регистры с операциями `Read`, `Write` и $`O`$.

Возникает естественный вопрос: можно ли скомбинировать несколько более слабых операций и повысить таким образом число потоков, для которых решается консенсус?

На лекции мы рассмотрели пример: оказалось, что комбинирование RMW-операций `Exchange` и `Fetch-And-Add`, каждая из которых имеет число консенсуса 2, все равно не позволяет решить задачу консенсуса для трех потоков.

В этой задаче мы рассмотрим другой пример:

Возьмем класс операций, в который помимо `Read` и `Write` входят операции `Increment` и `Multiply(v)`:

* `r.Increment()` - увеличивает значение регистра на 1
* `r.Multiply(v)` - умножает значение регистра на аргумент `v`.
 
Обе операции не возвращают значения, для его извлечения нужно явно выполнить `Read`.

Можно показать, что операции `Increment` и `Multiply` по отдельности имеют число консенсуса 1.

Рассмотрим задачу *бинарного* консенсуса, в которой потоки могут предлагать только значения 0 или 1.

Покажите, что заданный класс операций позволяет решать бинарный консенсус для произвольного числа потоков.

Протокол консенсуса должен работать для произвольного числа `n`.

---

Докажем, что число консенсуса в этом случае - $`\infty`$.

Зафиксруем произвольное число потоков $`n`$.
Пусть есть всего одна ячейка памяти - $`x`$, инициализированная $`-1`$.
Если значение потока - 0, то он вызывает `x.Multiply(n)`. Иначе, если значение - 1, вызывает `x.Increment()`.
Если в $`x < 0`$, то возвращаем 0. Иначе - 1.
Предположим значение первого потока - 0, тогда он вызовет `x.Multiply(n)` и изменит значение $`x`$ на $`-n`$. Какое бы ни было значение у оставшихся потоков, значение в ячейке $`x`$ останется отрицательным. Так как оставшихся потоков всего $`n-1`$ и увеличивать значение в ячейке они могут только операцией `x.Increment()`. Следовательно максимально увеличат его до значения $`-1`$.

Предположим значение первого потока - 1, тогда он вызовет `x.Increment()` и изменит значение $`x`$ на $`0`$. Какое бы ни было значение у оставшихся потоков, значение в ячейке $`x`$ останется положитеьным. Так как операциями `x.Increment()` и `x.Multiply(n)` не возможно поменять знак.

Следовательно для любого потока будет возвращаться значение первого пришедшего, то есть `Agreement` и `Validity` выполняются.

Так как в реализации нет циклов, то `Wait-Free Termination` также выполняется.

Так как $`n`$ брали произвольным это верно $`\forall{n}`$
